#!/bin/bash

# ================= Configuration Area =================
# Public IP Bridge Name
WAN_IF="vmbr0"

# Force locale to UTF-8
export LANG=C.UTF-8
export LC_ALL=C.UTF-8

# Configuration file paths
DB_FILE="/etc/port_forward_rules.db"
NFT_CONF="/etc/nftables.conf"

# Color definitions
RED='\033[1;31m'
GREEN='\033[1;32m'
YELLOW='\033[1;33m'
CYAN='\033[1;36m'
NC='\033[0m'
# =========================================

# Get private subnets of bridges, excluding the public IP bridge (usually vmbr0).
get_private_vmbr_subnets() {
    # Use ip route to get routing table
    # scope link: Only show directly connected routes
    # proto kernel: Only show routes automatically generated by the kernel (created after IP configuration)
    ip -o -4 route show scope link proto kernel | awk '
    function is_private(ip) {
        return (ip ~ /^10\./) || \
               (ip ~ /^172\.(1[6-9]|2[0-9]|3[0-1])\./) || \
               (ip ~ /^192\.168\./)
    }

    {
        iface = ""
        for(i=1; i<=NF; i++) {
            if($i == "dev") {
                iface = $(i+1)
                break
            }
        }

        # Logic: Interface name starts with vmbr AND is not vmbr0
        if (iface ~ /^vmbr/ && iface != "vmbr0") {
            # $1 in route output is the CIDR network address
            split($1, a, "/")
            ip = a[1]
            if (is_private(ip)) {
                print $1
            }
        }
    }'
}

# Get all qualifying private subnets
SUBNETS=$(get_private_vmbr_subnets)

# Check if private subnets were found
if [ -z "$SUBNETS" ]; then
    echo -e "${RED}No private subnets detected on vmbr*. Script stopping. Cannot configure port forwarding for NAT VMs.${NC}"
    echo -e "${RED}RFC 1918 defined private addresses: 10.0.0.0/8; 172.16.0.0/12; 192.168.0.0/16;${NC}"
    exit 0
else
    echo -e "${CYAN}> Detected the following private subnets:${NC}"
    for cidr in $SUBNETS; do
        echo "$cidr"
    done
fi

# Check Root privileges
if [ "$EUID" -ne 0 ]; then
  echo -e "${RED}Please run this script with root privileges!${NC}"
  exit 1
fi

# Initialize database file
if [ ! -f "$DB_FILE" ]; then
    touch "$DB_FILE"
fi

# Reminder of current PVE system SSH port and management interface port
get_system_ports() {
    # --- 1. Get SSH Port ---
    # Strategy 1: Use ss command to detect the port actually listened to by the sshd process
    local ssh_detected
    ssh_detected=$(ss -tlnp | grep -w "sshd" | head -n 1 | awk '{print $4}' | awk -F':' '{print $NF}')
    
    if [ -z "$ssh_detected" ]; then
        DETECTED_SSH_PORT=''
    else
        DETECTED_SSH_PORT=$ssh_detected
    fi
    
    # Strategy 2: If no running process is detected, analyze the configuration file
    if [ -z "$DETECTED_SSH_PORT" ]; then
        # Find non-commented Port lines
        CONFIG_PORT=$(grep "^Port " /etc/ssh/sshd_config | awk '{print $2}' | head -n 1)
        
        if [ -n "$CONFIG_PORT" ]; then
            DETECTED_SSH_PORT=$CONFIG_PORT
        else
            # Strategy 3: Configuration file is all comments (#Port 22), default to 22
            DETECTED_SSH_PORT=22
        fi
    fi

    # --- 2. Get PVE Web Port ---
    # Use ss command to detect pveproxy process
    local pve_detected
    pve_detected=$(ss -tlnp | grep "pveproxy" | head -n 1 | awk '{print $4}' | awk -F':' '{print $NF}')

    if [ -z "$pve_detected" ]; then
        DETECTED_PVE_PORT=8006
    else
        DETECTED_PVE_PORT=$pve_detected
    fi
    
    echo -e "> Host Current SSH Port: ${GREEN}${DETECTED_SSH_PORT}${NC} Management Interface Port: ${GREEN}${DETECTED_PVE_PORT}${NC}. Do not add forwarding for these two ports."
}
get_system_ports

# Ensure kernel forwarding is enabled and nftables starts on boot
setup_forwarding_env() {
    # If file does not exist (-f) OR (||) the line is not in the file, write it
    if [ ! -f /etc/sysctl.conf ] || ! grep -q "net.ipv4.ip_forward=1" /etc/sysctl.conf; then
        echo -e "${YELLOW}Kernel forwarding not enabled. Writing configuration...${NC}"
        echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf
        sysctl -p /etc/sysctl.conf > /dev/null
    fi
    
    # Check nftables enable on boot
    if ! systemctl is-enabled --quiet nftables; then
        echo -e "${YELLOW}nftables is not enabled on boot. Enabling...${NC}"
        systemctl enable nftables > /dev/null 2>&1
    fi
}
setup_forwarding_env

# --- Print Rules Table ---
# Arg $1: Filter mode (all, enabled, paused)
# Return: 0=Data displayed, 1=No data
show_rules_table() {
    local filter_mode=$1
    local found_count=0
    
    if [ ! -s "$DB_FILE" ]; then
        echo "No rules found."
        return 1
    fi

    # Unified Header
    printf "${YELLOW}%-4s %-8s %-10s %-12s %-16s %-12s %-12s %-s${NC}\n" "ID" "Status" "Proto" "LocalPort" "Dest IP" "DestPort" "Whitelist" "Remark"
    echo "------------------------------------------------------------------------------------------------"

    local i=1
    while IFS='|' read -r lport backend_ip backend_port proto remark status whitelist; do
        current_status=${status:-1}
        safe_remark=${remark:-"-"}
        
        # Determine whether to display this row
        local show_row=0
        if [ "$filter_mode" == "all" ]; then show_row=1; fi
        if [ "$filter_mode" == "enabled" ] && [ "$current_status" == "1" ]; then show_row=1; fi
        if [ "$filter_mode" == "paused" ] && [ "$current_status" == "0" ]; then show_row=1; fi

        if [ $show_row -eq 1 ]; then
            # Status Color
            if [ "$current_status" == "1" ]; then
                status_str="${GREEN}ON${NC}"
            else
                status_str="${RED}OFF${NC}"
            fi

            # Whitelist Display
            if [[ -n "$whitelist" ]]; then
                wl_display="Yes"
            else
                wl_display="No"
            fi

            # Print row
            printf "%-4s %-19b %-10s %-8s %-16s %-8s %-9s %-s\n" "$i" "$status_str" "$proto" "$lport" "$backend_ip" "$backend_port" "$wl_display" "$safe_remark"
            found_count=$((found_count + 1))
        fi
        
        # Regardless of display, line number must increment to keep ID consistent with file line number
        ((i++))
    done < "$DB_FILE"
    echo "======================"

    if [ $found_count -eq 0 ]; then
        if [ "$filter_mode" == "enabled" ]; then echo "No active rules."; fi
        if [ "$filter_mode" == "paused" ]; then echo "No paused rules."; fi
        return 1
    fi
    return 0
}

# --- Generate rules to write ---
# Arg $1: Generation mode (dnat, forward)
gen_nft_rule() {
    local gen_mode=$1

    # Read database file
    while IFS='|' read -r lport backend_ip backend_port proto remark status whitelist; do
        if [[ -n "$lport" ]]; then
            # status: 1=Enabled, 0=Paused (default 1 if empty)
            current_status=${status:-1}
            remark_text=${remark:-None}
            current_whitelist=${whitelist// /}
            
            # Only write config when status is 1
            if [ "$current_status" == "1" ]; then
                # Add comments to config file for debugging
                echo "        # Remark: $remark_text"

                # Handle Whitelist
                limit_str=""
                if [[ -n "$current_whitelist" ]]; then
                    # Replace Chinese comma with English comma
                    safe_whitelist=${current_whitelist//，/,}

                    # Check if string contains comma
                    if [[ "$safe_whitelist" == *","* ]]; then
                        # Contains comma, treat as IP list, add braces
                        limit_str="ip saddr { $safe_whitelist } "
                    else
                        # No comma, treat as single IP or subnet, no braces
                        limit_str="ip saddr $safe_whitelist "
                    fi
                fi
                
                # fib daddr type local: Query the Forwarding Information Base (FIB) to see if the packet's destination IP (daddr) belongs to the Host (PVE) itself. As long as the destination IP is a local IP, it will be matched and forwarded by the following DNAT rules.
                if [ "$proto" == "tcp+udp" ]; then
                    if [ "$gen_mode" == "dnat" ]; then
                        # prerouting dnat rules
                        echo "        fib daddr type local ${limit_str}tcp dport $lport dnat to $backend_ip:$backend_port"
                        echo "        fib daddr type local ${limit_str}udp dport $lport dnat to $backend_ip:$backend_port"
                    else
                        # forward accept rules
                        echo "        ${limit_str}ip daddr $backend_ip tcp dport $backend_port ct state new accept"
                        echo "        ${limit_str}ip daddr $backend_ip udp dport $backend_port ct state new accept"
                    fi
                else
                    if [ "$gen_mode" == "dnat" ]; then
                        # prerouting dnat rules
                        echo "        fib daddr type local ${limit_str}$proto dport $lport dnat to $backend_ip:$backend_port"
                    else
                        # forward accept rules
                        echo "        ${limit_str}ip daddr $backend_ip $proto dport $backend_port ct state new accept"
                    fi
                fi
                
                echo ""
            fi
        fi
    done < "$DB_FILE"
}

# Core function: Generate nftables config from database and apply. This will overwrite the original nftables.conf
apply_rules() {
    cat > "$NFT_CONF" <<EOF
#!/usr/sbin/nft -f

flush ruleset

table ip nat {
    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;
        
EOF

    # Get DNAT rules and write to config
    rules_content=$(gen_nft_rule dnat)
    if [[ -n "$rules_content" ]]; then
        echo "$rules_content" >> "$NFT_CONF"
    fi

    cat >> "$NFT_CONF" <<EOF
    }

    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;
        
        # [Critical: Only masquerade traffic going out to the public internet]
        # Based on the obtained private subnet list, set rules to change the source IP to the host IP only when packets go out through the public interface.
EOF

    # Masquerade traffic from private subnets accessing the public internet.
    for cidr in $SUBNETS; do
        echo "        ip saddr $cidr oifname \"$WAN_IF\" masquerade" >> "$NFT_CONF"
    done

    cat >> "$NFT_CONF" <<EOF
    }
}

table ip filter {
    chain input { type filter hook input priority 0; policy accept; }
    
    chain forward { 
        # Default policy changed to drop (reject all forwarding)
        type filter hook forward priority 0; policy drop;
        
        # Allow return packets for established connections (Critical!). Without this, reply packets are blocked, breaking forwarding.
        ct state established,related accept
        
        # Set rules for mutual access and public access based on the obtained private subnet list.
EOF

    # Allow mutual access between private subnets. Remove if access should be forbidden.
    for cidr in $SUBNETS; do
        echo "        ip saddr $cidr ip daddr $cidr ct state new accept" >> "$NFT_CONF"
    done
    echo "" >> "$NFT_CONF"

    # Allow private subnets to access public internet (stateless, suitable for network testing).
    for cidr in $SUBNETS; do
        echo "        ip saddr $cidr oifname \"$WAN_IF\" accept" >> "$NFT_CONF"
    done
    echo "" >> "$NFT_CONF"

    # Get accept rules and write to config
    rules_content=$(gen_nft_rule accept)
    if [[ -n "$rules_content" ]]; then
        echo "$rules_content" >> "$NFT_CONF"
    fi

    cat >> "$NFT_CONF" <<EOF
    }
    chain output { type filter hook output priority 0; policy accept; }
}
EOF

    # Choose command based on nftables service status
    if systemctl is-active --quiet nftables; then
        # Reload config if active
        systemctl reload nftables
    else
        # Restart service if stopped
        systemctl restart nftables
    fi
    
    local error_status=$?
    
    if [ $error_status -eq 0 ]; then
        echo -e "${GREEN}Configuration updated and applied!${NC}"
        return 0
    else
        echo -e "${RED}Failed to apply configuration. Please check if input is valid.${NC}"
        # Output last few lines of error log for troubleshooting
        echo -e "${YELLOW}Error Details (journalctl):${NC}"
        journalctl -xeu nftables.service | tail -n 10
        return 1
    fi
}

# 1. List all forwarding rules
list_rules() {
    echo -e "\n${CYAN}=== Current Port Forwarding Rules List ===${NC}"
    show_rules_table "all"
}

# 2. Add Port Forwarding
add_rule() {
    echo -e "\n${GREEN}>>> Add Port Forwarding Info${NC}"
    
    read -p "Local Listening Port (e.g., 8080): " lport
    read -p "Target IP (e.g., 172.16.1.10): " backend_ip
    read -p "Target Port (e.g., 80): " backend_port
    
    echo "Protocol Type:"
    echo "1) TCP"
    echo "2) UDP"
    echo "3) TCP + UDP"
    read -p "Select (1-3): " p_choice
    
    case $p_choice in
        1) proto="tcp" ;;
        2) proto="udp" ;;
        3) proto="tcp+udp" ;;
        *) echo -e "${RED}Invalid selection${NC}"; return ;;
    esac

    read -p "Remark (Optional): " user_remark
    # Remove pipe characters that might break formatting
    user_remark=${user_remark//|/}
    
    echo -e "\n${YELLOW}Set allowed IPs for local port (Whitelist)${NC}"
    echo "Format = 1.1.1.1,93.123.23.0/24 (comma separated); Empty = No restriction."
    echo "After adding, check ${DB_FILE} to view the whitelist later."
    read -p "Please enter: " whitelist_input
    whitelist_input=${whitelist_input// /}
    whitelist_input=${whitelist_input//|/}
    whitelist_input=${whitelist_input//，/,}

    # Use awk for smarter protocol conflict detection
    # Logic:
    # 1. Only check if port matches (Col 1 == lport)
    # 2. If existing proto == new proto -> Conflict
    # 3. If existing proto == "tcp+udp" -> Conflict regardless of new proto
    # 4. If new proto == "tcp+udp" -> Conflict if any rule exists for that port
    
    conflict_check=$(awk -F"|" -v new_port="$lport" -v new_proto="$proto" '
    $1 == new_port {
        if ($4 == new_proto || $4 == "tcp+udp" || new_proto == "tcp+udp") {
            print "1"
            exit
        }
    }' "$DB_FILE")

    if [ "$conflict_check" == "1" ]; then
        echo -e "${RED}Error: Forwarding protocol conflict on local port $lport!${NC}"
        echo -e "${YELLOW}Hint: The Port+Protocol to add conflicts with an existing rule. Do not add duplicates.${NC}"
        return
    fi
    
    # Backup config
    cp "$DB_FILE" "${DB_FILE}.bak"
    
    echo "$lport|$backend_ip|$backend_port|$proto|$user_remark|1|$whitelist_input" >> "$DB_FILE"
    apply_rules
    
    # Exception handling mechanism
    if [ $? -ne 0 ]; then
        echo -e "${YELLOW}>>> Configuration error detected. Auto-rolling back...${NC}"
        # Restore backup
        mv "${DB_FILE}.bak" "$DB_FILE"
        # Apply backed-up correct config
        apply_rules > /dev/null 2>&1
        echo -e "${GREEN}Rollback complete. The new forwarding rule has been revoked. Please check if the service is running normally.${NC}"
    else
        # Delete backup on success
        rm -f "${DB_FILE}.bak"
    fi
}

# Internal function: Pause forwarding
pause_rule_logic() {
    echo -e "\n${CYAN}>>> Pause Port Forwarding${NC}"
    echo -e "(Only showing currently [Enabled] rules)"
    
    # Call public function to show "enabled" rules and get return value
    if ! show_rules_table "enabled"; then
        return
    fi

    read -p "Enter Rule ID to [Pause]: " target_id
    
    total_lines=$(wc -l < "$DB_FILE")
    if [[ "$target_id" =~ ^[0-9]+$ ]] && [ "$target_id" -le "$total_lines" ] && [ "$target_id" -gt 0 ]; then
        awk -v line="$target_id" -v FS="|" -v OFS="|" 'NR==line {$6="0"} {print}' "$DB_FILE" > "${DB_FILE}.tmp" && mv "${DB_FILE}.tmp" "$DB_FILE"
        echo -e "${YELLOW}Rule ID $target_id paused.${NC}"
        apply_rules
    else
        echo -e "${RED}Invalid ID${NC}"
    fi
}

# Internal function: Enable forwarding
enable_rule_logic() {
    echo -e "\n${CYAN}>>> Re-enable Port Forwarding${NC}"
    echo -e "(Only showing currently [Paused] rules)"
    
    # Call public function to show "paused" rules and get return value
    if ! show_rules_table "paused"; then
        return
    fi

    read -p "Enter Rule ID to [Enable]: " target_id
    
    total_lines=$(wc -l < "$DB_FILE")
    if [[ "$target_id" =~ ^[0-9]+$ ]] && [ "$target_id" -le "$total_lines" ] && [ "$target_id" -gt 0 ]; then
        awk -v line="$target_id" -v FS="|" -v OFS="|" 'NR==line {$6="1"} {print}' "$DB_FILE" > "${DB_FILE}.tmp" && mv "${DB_FILE}.tmp" "$DB_FILE"
        echo -e "${GREEN}Rule ID $target_id re-enabled.${NC}"
        apply_rules
    else
        echo -e "${RED}Invalid ID${NC}"
    fi
}

# 3. Manage Forwarding State - Pause/Enable
manage_state() {
    echo -e "\n${YELLOW}>>> Manage Port Forwarding State${NC}"
    echo "1. Pause Forwarding"
    echo "2. Enable Forwarding"
    echo "3. Return to previous menu"
    read -p "Select operation [1-3]: " sub_choice
    
    case $sub_choice in
        1) pause_rule_logic ;;
        2) enable_rule_logic ;;
        3) return ;;
        *) echo "Invalid input" ;;
    esac
}

# 4. Delete Port Forwarding
del_rule() {
    echo -e "\n${RED}>>> Delete Port Forwarding${NC}"
    # Call all mode here, convenient for user to view all rules before deleting
    if ! show_rules_table "all"; then
        return
    fi
    
    read -p "Enter Rule ID to delete: " del_id
    total_lines=$(wc -l < "$DB_FILE")
    
    if [[ "$del_id" =~ ^[0-9]+$ ]] && [ "$del_id" -le "$total_lines" ] && [ "$del_id" -gt 0 ]; then
        sed -i "${del_id}d" "$DB_FILE"
        apply_rules
    else
        echo -e "${RED}Invalid ID${NC}"
    fi
}

# 5. Restore/Reload Configuration
restore_config() {
    echo -e "\n${YELLOW}>>> Restoring configuration...${NC}"
    # Check if database has content
    if [ ! -s "$DB_FILE" ]; then
        echo -e "${RED}Error: Database file (${DB_FILE}) is empty or missing. Cannot restore.${NC}"
        echo -e "Please add at least one rule first."
        return
    fi
    # Force call apply_rules to rewrite and restart
    echo "Reading database and rewriting nftables configuration..."
    apply_rules
}

# Main Menu
while true; do
    echo -e "\n${CYAN}PVE-NAT Port Forwarding Management${NC}"
    if systemctl is-active --quiet nftables; then
        nft_status="${GREEN}● Running${NC}"
    else
        nft_status="${RED}● Stopped${NC}"
    fi
    echo -e "nftables Service Status: ${nft_status}${NC}"
    echo "1. List All Forwarding"
    echo "2. Add Port Forwarding"
    echo "3. Pause/Enable Forwarding"
    echo "4. Delete Port Forwarding"
    echo "5. Restore/Reload Config"
    echo "6. Exit"
    read -p "Enter choice [1-6]: " choice

    case $choice in
        1) list_rules ;;
        2) add_rule ;;
        3) manage_state ;;
        4) del_rule ;;
        5) restore_config ;;
        6) exit 0 ;;
        *) echo "Invalid input" ;;
    esac
done